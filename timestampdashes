#!/usr/bin/env bash
#
#                               timestampdashes
#                          Renames files to the form 
#                          "YYYY-MM-DD_hh-mm-ss.ext"
#
#                        Copyright(c)2015 Jonas Sj√∂berg
#                        https://github.com/jonasjberg
#_______________________________________________________________________________
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#      the Free Software Foundation, either version 3 of the License, or
#                     (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#                 GNU General Public License for more details.
#
#      You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#_______________________________________________________________________________

set -e                                                  # exit on first error
#set -x                                                 # debug mode
DEBUG_MODE=false                                        #


msg_debug()
{
    if [[ "$DEBUG_MODE" == true ]]; then
        echo "DEBUG: $*"
    fi
}


process()
{
    local name="$@"
    local safechars="0-9"

    # Remove 'IMG', underlines, slashes and dots
    name=$(echo "${name//IMG/}")
    name=$(echo "${name//_/}")
    name=$(echo "${name//-/}")
    name=$(echo "${name//./}")

    # Remove everything except 'safechars'
    name=$(echo "${name//[^${safechars}]/}")

    # Add dashes and underlines at set positions for a final result like:
    # 2015-01-01_01-00-00
    name=$(echo "${name}" | sed 's/./-&/5' | sed 's/./-&/8' | sed 's/./_&/11')
    name=$(echo "${name}" | sed 's/./-&/14'| sed 's/./-&/17')

    echo "${name}" # Function "return" value
}


# ______________________________________________________________________________
# MAIN ROUTINE EXECUTION STARTS HERE
if [[ -z ${1} ]];
then
    echo "Argument missing! EXITING .."
    exit 1
fi

# Nicked from response by "Doctor J" at http://stackoverflow.com/a/1403489
fullpath="${1}"
filename="${fullpath##*/}"                      # Strip longest match of */ from start
dir="${fullpath:0:${#fullpath} - ${#filename}}" # Substring from 0 thru pos of filename
base="${filename%.[^.]*}"                       # Strip shortest match of . plus at least one non-dot char from end
ext="${filename:${#base} + 1}"                  # Substring from len of base thru end
if [[ -z "$base" && -n "$ext" ]]; then          # If we have an ext and no base, it's really the base
    base=".$ext"
    ext=""
fi

msg_debug "fullpath: $fullpath"
msg_debug "filename: $filename"
msg_debug "dir:      $dir"
msg_debug "base:     $base"
msg_debug "ext:      $ext"


# Figure out new name. Exit if result is empty.
base_new="$(process "${base}")"
msg_debug "base_new: ${base_new}"

if [[ -z ${base_new} ]];
then
    echo "process result is NULL! EXITING .."
    exit 1
fi


# If the base is the same as the ext, there is no ext.
if [[ "${base}" == "${ext}" ]]
then
    ext=''
    name_done="${base_new}"
else
    name_done="${base_new}.${ext}"
fi


# Print out result or rename the file.
if [[ "$DEBUG_MODE" == true ]]; then
    echo "${name_done}"
    exit 0
else
    if [[ "${filename}" != "${name_done}" ]]
    then
        mv -nv -- "${filename}" "${name_done}"
    fi
fi


exit $?
