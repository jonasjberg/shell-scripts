#!/usr/bin/env bash
#                                 .----------.
#                                clampimgheight
#                                 '----------'
#
#      Columnate images taller than IMAGE_HEIGHT_MAX using ImageMagick.
#   Useful for processing very tall images produced by the 'www2png' script.
# Doesn't hard limit the height but tries its best to equally divide the image
# into the number of columns needed while keeping the split images height equal.
#   Thus, the output image height may deviate slightly from the set maximum.
#
#                        Copyright(c)2015 Jonas Sj√∂berg
#                        https://github.com/jonasjberg
#_______________________________________________________________________________
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#      the Free Software Foundation, either version 3 of the License, or
#                     (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#                 GNU General Public License for more details.
#
#      You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#_______________________________________________________________________________


IMAGE_HEIGHT_MAX=2000

set -e                                                  # exit on first error
#set -x                                                 # debug mode

DEBUG=true
PROGNAME=$(basename $0)                                 # name of this script
TEMPDIR=$(mktemp -d /tmp/${PROGNAME}.XXXXXX)            # temporary directory
DEFAULT_ERROR_MSG="Unknown (unspecified) error!"
DEFAULT_ERROR_CODE=2

#_______________________________________________________________________________


function die()
{
    msg=${2:-$DEFAULT_ERROR_MSG}
    echo "${PROGNAME} execution failed!" 1>&2
    echo "Error message: ${msg}" 1>&2
    exit ${1:-$DEFAULT_ERROR_CODE}
}


function msg_warn()
{
    echo "WARNING: $*" >&2
}


function msg_debug()
{
    if [[ "$DEBUG_MODE" == true ]]
    then
        echo "DEBUG: $*"
    fi
}


function check_convert_installed()
{
    if ! command -v "convert" >/dev/null
    then
        die "Can not execute convert! Is it installed? Is it in your \$PATH?"
    fi
}


function process_image()
{
    local input=${1}

    # Get output file name from second argument or default to "DEFAULT_output".
    # Variable substitutions:  ${input%.*}  strips any extension
    #                          ${input##*.} strips everything but the extension
    local ext=${input##*.}
    local input_no_ext=${input%.*}

    # Second argument is the output filename, use default if not present.
    local DEFAULT_output="${input_no_ext}_CLAMPED.${ext}"
    output=${2:-$DEFAULT_output}

    # Get a name for intermediate files.
    # Variable substitutions:  ${input%.*}  strips any extension
    #                          ${input##*.} strips everything but the extension
    local horiz_split="${TEMPDIR}/${input_no_ext}_%02d.${ext}"

    # Chop up image horizontally in 'number_of_splits' pieces.
    # http://www.imagemagick.org/Usage/crop/#crop_equal
    convert "${input}" -crop 1x${number_of_splits}@ +repage +adjoin "${horiz_split}"

    # Merge all pieces horizontally.
    # http://www.imagemagick.org/Usage/layers/
    # http://www.imagemagick.org/Usage/option_link.cgi?append
    convert +append "${TEMPDIR}/*.${ext}" "${output}"

}


function get_image_height()
{
    local image_height=$(identify -format "%h" "${1}")
    echo "$image_height"
}

function main()
{
    # Set input file name(s)
    local input=${1}
    local input_no_ext=${input%.*}
    local extension="${input##*.}"

    if [[ ! -f ${input} ]]
    then
        msg_warn "'${input}' is not a file!"
        return 1
    fi


    # Initialize counter and get initial image height.
    number_of_splits=1
    initial_image_height=$(get_image_height "${input}")

    # Check if initial image height is less than or equal to IMAGE_HEIGHT_MAX.
    if [[ $initial_image_height -le $IMAGE_HEIGHT_MAX ]]
    then
        die 1 "Image height is already less than or equal to IMAGE_HEIGHT_MAX"
    fi

    # Get the number of vertical splits needed.
    target_image_height=$initial_image_height
    while [[ $target_image_height -gt $IMAGE_HEIGHT_MAX ]]
    do
        target_image_height=$((${initial_image_height} / ${number_of_splits}))
        number_of_splits=$[$number_of_splits +1]
    done


    if [[ -z $number_of_splits ]]
    then
        die 1 "Failed to calculate number of splits"
    fi

    msg_debug "           input filename: ${input}"
    msg_debug "             image height: ${initial_image_height}"
    msg_debug "         IMAGE_HEIGHT_MAX: ${IMAGE_HEIGHT_MAX}"
    msg_debug "number of splits required: ${number_of_splits}"

    process_image ${input} ${2}
}

#_______________________________________________________________________________
# ______________________________________________________________________________
# MAIN ROUTINE EXECUTION STARTS HERE

if [[ $# -eq 0 ]]
then
    die 1 "Positional arguments missing! At least one is required."
else
    check_convert_installed

    if [[ $# -eq 2 ]]
    then
        echo "input and output is specified"
        main "${1}" "${2}"
        mv -nv "${output}" "${2}"
    else 
        for file in "$@"
        do
            msg_debug "------------------------------------------------------------"
            msg_debug "Now processing file '${file}'"
            main "${file}"
        done
    fi
fi


exit $?

