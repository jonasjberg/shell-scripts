#!/usr/bin/env bash
#
# slugify-filename
# ~~~~~~~~~~~~~~~~
# Copyright(c)2015 Jonas Sj√∂berg
# https://github.com/jonasjberg
#
# Does filename cleanup. I try to use very conservative filenames.
# ASCII, no spaces, braces, brackets, commas, dots, etc.
# This script is meant to automate a lot of tedious renaming.
# I use dashes instead of spaces and underlines for "field" separation.
# For instance: "an-artist_01_a-track.mp3"
# This script also does some substitutions, like replacing
# '@' with 'AT', '&' with 'and', 'C++' with 'Cplusplus', etc.
#_______________________________________________________________________________
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#_______________________________________________________________________________


DEBUG_MODE=false
VERBOSE_MODE=false
SPACE_CHAR='-'
SEPAR_CHAR='_'

#_______________________________________________________________________________


msg_debug()
{
    if [[ "$DEBUG_MODE" == true ]]; then
        echo "${name_full}"
    fi
}

msg_prompt()
{
    if [[ "$VERBOSE_MODE" == true ]]; then
        echo -e "\n[*] $* .."
    fi
}

msg_progress()
{
    if [[ "$VERBOSE_MODE" == true ]]; then
        echo "    $*"
    fi
}

die()
{
    echo "ERROR: $*"
    exit 1
}

process()
{
    local name="$@"
    local gluechars='-_'
    local safechars="${gluechars}a-zA-Z0-9"

    if [[ -z ${name} ]];
    then
        die "process() function argument missing!"
    fi

    #name=${name%/}                        # Remove trailing slash if present
    #echo "name: ${name}"

    # ------------------------------------------------------------------------------
    # Replace '&' with '-and-'
    name=$(echo "${name//&/-and-/g}")
    msg_debug

    # Replace ' -and- ' with '-and-'
    name=$(echo "${name//\ -and-\ /-and-/g}")
    msg_debug

    # ------------------------------------------------------------------------------
    # Replace common words
    name=$(echo "${name//C++/C-plusplus/g}")
    name=$(echo "${name//C#/C-sharp/g}")

    # ------------------------------------------------------------------------------
    # Replace '@' with '-AT-'
    name=$(echo "${name//@/-AT-/g}")
    msg_debug

    # Replace ' -AT- ' with '-AT-'
    name=$(echo "${name//\ -AT-\ /-AT-/g}")
    msg_debug

    # ------------------------------------------------------------------------------
    # Replace everything that is not in 'safechars' with a dash
    name=$(echo "${name//[^${safechars}]/-}")
    msg_debug

    # ------------------------------------------------------------------------------
    # Replace two or more dashes with a underline
    #name=$(echo "${name//[-]{2,}/_/g}")
    name=$(echo $name | sed -r 's/[-]{2,}/_/g')
    msg_debug

    # Replace -_- with _
    name=$(echo "${name//-_-/_}")
    msg_debug

    # Replace -_ with _
    name=$(echo "${name//-_/_}")
    msg_debug

    # Replace _- with _
    name=$(echo "${name//_-/_}")
    msg_debug

    # ------------------------------------------------------------------------------
    # Remove any dashes and underlines if first or last in name
    name=$(echo $name | sed -r 's/^[_-]+//g')
    name=$(echo $name | sed -r 's/[_-]+$//g')
    msg_debug

    # Collapse repeating characters
    #name=$(echo $name| tr -s '_' '_' | tr -s '-' '-')
    #msg_debug

    echo "${name}" # Function "return" value
}

process_hard()
{
    local name="$@"

    if [[ -z ${name} ]];
    then
        die "process_hard() function argument missing!"
    fi

    # Remove everything other than a-z, A-Z and 0-9
    name=$(echo $name | sed 's/[^a-zA-Z0-9]//g')

    echo "${name}" # Function "return" value
}



# MAIN ROUTINE EXECUTION STARTS HERE
msg_prompt "RUNNING"

name_full="${1}"
name_no_path="${name_full##*/}"
extension="${name_full##*.}"
name_no_ext=${name_full%.*}

msg_progress "name_full:      $name_full"
msg_progress "name_no_path:   $name_no_path"
msg_progress "extension:      $extension"
msg_progress "name_no_ext:    $name_no_ext"


if [[ -z ${name_no_ext} ]];
then
    msg_prompt "name without extension is EMPTY"
    name_no_ext=".${extension}"
    extension=''
    msg_progress "name_full:      $name_full"
    msg_progress "name_no_path:   $name_no_path"
    msg_progress "extension:      $extension"
    msg_progress "name_no_ext:    $name_no_ext"
fi


if [[ ! -z ${extension} ]];
then
    msg_prompt "extension is set"

    if [[ "${extension}" == "${name_full}" ]];
    then
        msg_prompt "extension is equal to full name. Setting to NULL"
        extension=''
    else
        msg_prompt "slugifying extension"
        extension=$(process_hard "${extension}")
        extension=".${extension}"
        msg_progress "extension:      $extension"
    fi
fi

msg_prompt "slugifying name"
name_new="$(process "${name_no_ext}")"
msg_progress "name_new:       $name_new"


#if [[ -z ${extension} ]];
#then
    #msg_prompt "adding back leading dot"
    #name_new=".${name_new}"
#fi

if [[ -z ${name_new} ]];
then
    die "process result is NULL!"
fi

name_new_full="${name_new}${extension}"
msg_progress "name_new_full:  $name_new_full"

if [[ "${name_full}" != "${name_new_full}" ]];
then
    msg_prompt "DONE! Result is not equal to input"
else
    msg_prompt "DONE! nothing changed"
fi


echo "${name_new_full}"
