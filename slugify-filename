#!/usr/bin/env bash
#
# slugify-filename
# ~~~~~~~~~~~~~~~~
# Copyright(c)2015-2017 Jonas Sj√∂berg
# https://github.com/jonasjberg
#
# Does filename cleanup. I try to use very conservative filenames.
# ASCII, no spaces, braces, brackets, commas, dots, etc.
# This script is meant to automate a lot of tedious renaming.
# I use dashes instead of spaces and underlines for "field" separation.
# For instance: "an-artist_01_a-track.mp3"
# This script also does some substitutions, like replacing
# '@' with 'AT', '&' with 'and', 'C++' with 'Cplusplus', etc.
#_______________________________________________________________________________
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#_______________________________________________________________________________


DEBUG_MODE=false
TEST_MODE=false
VERBOSE_MODE=false
SPACE_CHAR='-'
SEPAR_CHAR='_'
GLUE_CHARS='-_'
SAFE_CHARS="${GLUE_CHARS}a-zA-Z0-9"

#_______________________________________________________________________________


msg_debug()
{
    if [[ "$DEBUG_MODE" == true ]]; then
        printf "%s\n" "${name_full}"
    fi
}

msg_prompt()
{
    if [[ "$VERBOSE_MODE" == true ]]; then
        printf "\n[*] %s ..\n" "$*"
    fi
}

msg_progress()
{
    if [[ "$VERBOSE_MODE" == true ]]; then
        printf "    %s\n" "$*"
    fi
}

die()
{
    printf "[ERROR]: %s\n" "$*"
    exit 1
}

process()
{
    local name="$@"

    name="${name//&/-and-}"             # Replace '&' with '-and-'
    name="${name//\ -and-\ /-and-}"     # Replace ' -and- ' with '-and-'
    msg_debug

    # Replace special words
    name="${name//C++/C-plusplus}"
    name="${name//C#/C-sharp}"

    # Remove these words
    REMOVE_STRING[0]='V413HAV'
    REMOVE_STRING[1]='EPUB'
    REMOVE_STRING[2]='STORMRG'
    REMOVE_STRING[3]='GOLU'
    REMOVE_STRING[4]='TLU622'
    REMOVE_STRING[5]='darksiderg'
    REMOVE_STRING[6]='ebook'

    for string in "${REMOVE_STRING[@]}"
    do
        name="${name//${string}/}"
        msg_debug
    done


    name="${name//@/-AT-}"              # Replace '@' with '-AT-'
    name="${name//\ -AT-\ /-AT-}"       # Replace ' -AT- ' with '-AT-'
    msg_debug

    # Replace everything that is not in 'SAFE_CHARS' with 'SPACE_CHAR'
    name="${name//[^${SAFE_CHARS}]/${SPACE_CHAR}}"
    msg_debug

    # Replace two or more dashes with a underline, collapse underlines
    name="$(echo "$name" | sed -r 's/[-]{2,}/_/g')"
    name="$(echo "$name" | sed -r 's/[_]{2,}/_/g')"
    msg_debug

    # Replace '-_-', '-_' and '_-' with SEPAR_CHAR
    name="${name//-_-/${SEPAR_CHAR}}"
    name="${name//-_/${SEPAR_CHAR}}"
    name="${name//_-/${SEPAR_CHAR}}"
    msg_debug

    # Remove any leading and trailing dashes/underlines
    name="$(echo "$name" | sed -r 's/^[_-]+//g')"
    name="$(echo "$name" | sed -r 's/[_-]+$//g')"
    msg_debug


    echo "${name}" # Function "return" value
}

process_hard()
{
    local name="$@"

    # Remove everything other than a-z, A-Z and 0-9
    name="$(echo "$name" | sed 's/[^a-zA-Z0-9]//g')"

    echo "${name}" # Function "return" value
}

main()
{
    name_full="${1}"
    name_no_path="${name_full##*/}"
    extension="${name_full##*.}"
    name_no_ext="${name_full%.*}"

    msg_progress "name_full:      ${name_full}"
    msg_progress "name_no_path:   ${name_no_path}"
    msg_progress "extension:      ${extension}"
    msg_progress "name_no_ext:    ${name_no_ext}"

    if [[ ! -z ${extension} ]]
    then
        msg_prompt "slugifying extension"
        extension="$(process "${extension}")"
        msg_progress "extension:      ${extension}"
    fi

    if [[ ! -z ${name_no_ext} ]]
    then
        msg_prompt "slugifying name_no_ext"
        name_no_ext="$(process "${name_no_ext}")"
        msg_progress "name_no_ext:    ${name_no_ext}"
    fi

    if [[ -z ${name_no_ext} ]]
    then
        msg_prompt "name without extension is EMPTY! setting to .extension"
        name_no_ext=".${extension}"
        extension=''
        msg_progress "extension:      ${extension}"
        msg_progress "name_no_ext:    ${name_no_ext}"
    fi


    if [[ ! -z ${extension} ]]
    then
        msg_prompt "extension is *not* NULL"

        if [[ "${extension}" == "${name_no_ext}" ]]
        then
            msg_prompt "extension is equal to full name. Setting to NULL"
            extension=''
            #name_no_ext=".${name_no_ext}"
        else
            extension=".${extension}"
            msg_progress "extension:      ${extension}"
        fi
    fi


    name_new="${name_no_ext}"
    msg_progress "name_new:       ${name_new}"

    if [[ -z ${name_new} ]]
    then
        msg_debug "process result is NULL!"
        return
    fi


    name_new_full="${name_new}${extension}"
    msg_progress "name_new_full:  $name_new_full"

    if [[ "${name_full}" != "${name_new_full}" ]]
    then
        msg_prompt "DONE! Result is not equal to input"
    else
        msg_prompt "DONE! nothing changed"
    fi


    if [[ "$DEBUG_MODE" == true ]] || [[ "$TEST_MODE" == true ]]
    then
        echo "${name_new_full}"
        return
    else
        mv -n "${1}" "${name_new_full}"
    fi
}



# ______________________________________________________________________________
# MAIN ROUTINE EXECUTION STARTS HERE

if [ $# -eq 0 ]
then
    die "Positional arguments missing! At least one is required."
else
    for arg in "$@"
    do
        main "${arg}"
    done
fi

exit $?

