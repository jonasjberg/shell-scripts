#!/usr/bin/env bash
#
# slugify-filename
# ~~~~~~~~~~~~~~~~
# Copyright(c)2015 Jonas Sj√∂berg
# https://github.com/jonasjberg
#
# Does filename cleanup. I try to use very conservative filenames.
# ASCII, no spaces, braces, brackets, commas, dots, etc.
# This script is meant to automate a lot of tedious renaming.
# I use dashes instead of spaces and underlines for "field" separation.
# For instance: "an-artist_01_a-track.mp3"
# This script also does some substitutions, like replacing
# '@' with 'AT', '&' with 'and', 'C++' with 'Cplusplus', etc.
#_______________________________________________________________________________
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#_______________________________________________________________________________


DEBUG_MODE=false
VERBOSE_MODE=false
SPACE_CHAR='-'
SEPAR_CHAR='_'
GLUE_CHARS='-_'
SAFE_CHARS="${GLUECHARS}a-zA-Z0-9"

#_______________________________________________________________________________


msg_debug()
{
    if [[ "$DEBUG_MODE" == true ]]; then
        echo "${name_full}"
    fi
}

msg_prompt()
{
    if [[ "$VERBOSE_MODE" == true ]]; then
        echo -e "\n[*] $* .."
    fi
}

msg_progress()
{
    if [[ "$VERBOSE_MODE" == true ]]; then
        echo "    $*"
    fi
}

die()
{
    echo "ERROR: $*"
    exit 1
}

process()
{
    local name="$@"

    name=$(echo "${name//&/-and-}")             # Replace '&' with '-and-'
    name=$(echo "${name//\ -and-\ /-and-}")     # Replace ' -and- ' with '-and-'
    msg_debug

    # Replace special words
    name=$(echo "${name//C++/C-plusplus}")
    name=$(echo "${name//C#/C-sharp}")
    
    # Remove these words
    REMOVE_STRING[0]='V413HAV'
    REMOVE_STRING[1]='EPUB'
    REMOVE_STRING[2]='STORMRG'
    REMOVE_STRING[3]='GOLU'
    REMOVE_STRING[4]='TLU622'
    REMOVE_STRING[5]='darksiderg'
    REMOVE_STRING[6]='ebook'
    
    for string in "${REMOVE_STRING[@]}"
    do
        name=$(echo "${name//${string}/}")
        msg_debug
    done


    name=$(echo "${name//@/-AT-}")              # Replace '@' with '-AT-'
    name=$(echo "${name//\ -AT-\ /-AT-}")       # Replace ' -AT- ' with '-AT-'
    msg_debug

    # Replace everything that is not in 'SAFE_CHARS' with a dash
    name=$(echo "${name//[^${SAFE_CHARS}]/-}")
    msg_debug

    # Replace two or more dashes with a underline, collapse underlines
    name=$(echo $name | sed -r 's/[-]{2,}/_/g')
    name=$(echo $name | sed -r 's/[_]{2,}/_/g')
    msg_debug

    name=$(echo "${name//-_-/${SEPAR_CHAR}}")   # Replace -_- with _
    name=$(echo "${name//-_/${SEPAR_CHAR}}")    # Replace -_ with _
    name=$(echo "${name//_-/${SEPAR_CHAR}}")    # Replace _- with _
    msg_debug

    # Remove any dashes and underlines if first or last in name
    name=$(echo $name | sed -r 's/^[_-]+//g')
    name=$(echo $name | sed -r 's/[_-]+$//g')
    msg_debug


    echo "${name}" # Function "return" value
}

process_hard()
{
    local name="$@"

    # Remove everything other than a-z, A-Z and 0-9
    name=$(echo $name | sed 's/[^a-zA-Z0-9]//g')

    echo "${name}" # Function "return" value
}

process_second_run()
{
    local name="$@"

    # Replace dashes with underlines for special fields 
    MATCH_FIELD[0]='1st-Edition'
    MATCH_FIELD[1]='2nd-Edition'
    MATCH_FIELD[2]='3rd-Edition'
    MATCH_FIELD[3]='4th-Edition'
    MATCH_FIELD[4]='5th-Edition'
    MATCH_FIELD[5]='6th-Edition'
    MATCH_FIELD[6]='7th-Edition'
    MATCH_FIELD[7]='8th-Edition'
    MATCH_FIELD[8]='9th-Edition'

    for match in "${MATCH_FIELD[@]}"
    do
        name=$(echo "${name//-${match}-/_${match}_}")
        msg_debug
    done

    #if [[ $NAME =~ [$[0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{2}-[0-9]{2}-[0-9]{2}] ]]
    #then
    # TODO: Check for date-like patterns (2015-01-01-11-11-11) and rename appropriately.
    #fi

    echo "${name}" # Function "return" value
}

main()
{
    name_full="${1}"
    name_no_path="${name_full##*/}"
    extension="${name_full##*.}"
    name_no_ext=${name_full%.*}

    msg_progress "name_full:      $name_full"
    msg_progress "name_no_path:   $name_no_path"
    msg_progress "extension:      $extension"
    msg_progress "name_no_ext:    $name_no_ext"

    if [[ ! -z ${extension} ]]
    then
        msg_prompt "slugifying extension"
        extension="$(process "${extension}")"
        msg_progress "extension:      $extension"
    fi

    if [[ ! -z ${name_no_ext} ]]
    then
        msg_prompt "slugifying name_no_ext"
        name_no_ext="$(process "${name_no_ext}")"
        msg_progress "name_no_ext:    $name_no_ext"
    fi

    if [[ -z ${name_no_ext} ]]
    then
        msg_prompt "name without extension is EMPTY! setting to .extension"
        name_no_ext=".${extension}"
        extension=''
        msg_progress "extension:      $extension"
        msg_progress "name_no_ext:    $name_no_ext"
    fi


    if [[ ! -z ${extension} ]]
    then
        msg_prompt "extension is *not* NULL"

        if [[ "${extension}" == "${name_no_ext}" ]]
        then
            msg_prompt "extension is equal to full name. Setting to NULL"
            extension=''
            #name_no_ext=".${name_no_ext}"
        else
            extension=".${extension}"
            msg_progress "extension:      $extension"
        fi
    fi


    name_new="${name_no_ext}"
    msg_progress "name_new:       $name_new"

    msg_prompt "start second run process"
    name_new="$(process_second_run "${name_new}")"
    msg_progress "name_new:       $name_new"

    if [[ -z ${name_new} ]]
    then
        msg_debug "process result is NULL!"
        return
    fi


    name_new_full="${name_new}${extension}"
    msg_progress "name_new_full:  $name_new_full"

    if [[ "${name_full}" != "${name_new_full}" ]]
    then
        msg_prompt "DONE! Result is not equal to input"
    else
        msg_prompt "DONE! nothing changed"
    fi


    if [[ "$DEBUG_MODE" == true ]]
    then
        echo "${name_new_full}"
        return
    else
        mv -n "${1}" "${name_new_full}"
    fi
}



# ______________________________________________________________________________
# MAIN ROUTINE EXECUTION STARTS HERE

if [ $# -eq 0 ]
then
    die "Positional arguments missing! At least one is required."
else
    for arg in "$@"
    do
        main "${arg}"
    done
fi

exit $?

