#!/usr/bin/env bash
#                                 ~~~~~~~~~~~
#                                 exif-rename
#                                 ~~~~~~~~~~~
#                    Copyright (C) 2015-2017 Jonas Sj√∂berg
#                        https://github.com/jonasjberg
#
#                 Rename images based on exif time/date data.
#      Searches the output of "exiftool" for contents of "SEARCHSTRINGS"
#     Contents of SEARCHSTRINGS are ordered by priority, from high to low.
#      The first match is used, so put whatever exif-fields that are more
#      likely to contain the correct date/time higher in the list below.
#    Compared to similar programs/scripts out there, this is a particularly
#       poor implementation with astonishingly lackluster functionality.
#     ____________________________________________________________________
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#      the Free Software Foundation, either version 3 of the License, or
#                     (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#                 GNU General Public License for more details.
#
#      You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

set -o noclobber -o nounset -o pipefail


# Example exiftool output this script will process:
# 
# > $ exiftool 2015-01-31\ 00.25.39.jpg | grep -i date
#
#     File Modification Date/Time     : 2015:01:31 00:25:39+01:00
#     File Access Date/Time           : 2015:06:04 05:58:32+02:00
#     File Inode Change Date/Time     : 2015:05:20 12:29:25+02:00
#     Modify Date                     : 2015:01:31 00:25:39
#     Date/Time Original              : 2015:01:31 00:25:39
#     Create Date                     : 2015:01:31 00:25:39

# Search strings ordered by priority, from high to low;
SEARCHSTRINGS[0]='Create Date'
SEARCHSTRINGS[1]='Date/Time Created'
SEARCHSTRINGS[2]='Date/Time Original'
SEARCHSTRINGS[3]='Date/Time Digitized'
SEARCHSTRINGS[4]='Media Create Date'
SEARCHSTRINGS[5]='Track Create Date'
SEARCHSTRINGS[6]='Metadata Date'
#SEARCHSTRINGS[7]='Modify Date'
#SEARCHSTRINGS[8]='Modification Date'
#SEARCHSTRINGS[9]='Profile Date Time'
#SEARCHSTRINGS[10]='File Access Date/Time'

VERBOSE_MODE=false
DEBUG_MODE=false


PROGNAME="$(basename $0)"

msg_status()
{
    if [ "$VERBOSE_MODE" == 'true' ]
    then
        [ -n "$1" ] && printf "\n%s: %s\n" "$PROGNAME" "$1" 1>&2
    fi
}

msg_warning()
{
    if [ "$VERBOSE_MODE" == "true" ]
    then
        [ -n "$1" ] && printf "\nWARNING: %s\n" "$1" 1>&2
    fi
}

msg_debug()
{
    [ "$DEBUG_MODE" == "true" ] && echo "DEBUG: $*" 1>&2
}

die()
{
    printf "\nERROR: %s\n" "$*"
    printf "EXITING ..\n"
    exit 1
}

clean_up_timestamp()
{
    local tstp="$1"
    tstp="${tstp//:/-}"                         # replace any : with -
    tstp="${tstp//+/-}"                         # replace any + with -
    tstp="${tstp//\ /_}"                        # replace any spaces with _
    tstp="$(echo $tstp | sed 's/^[_-]+//g')"    # remove any leading _ or -
    echo "$tstp"                                # function "return"
}

find_timestamp()
{
    local image="$1"

    # start grepping exif data, break when match found
    for str in "${SEARCHSTRINGS[@]}"
    do
        timestamp="$(exiftool "$image" | grep -ai --max-count=1 "$str" | cut -d':' -f2-)"

        # Optional additional filter
        # timestamp="$(grep -v -- "2015" <<< "$timestamp")"
        # timestamp="$(grep -v -- "2016" <<< "$timestamp")"
        timestamp="$(grep -iv -- "binary" <<< "$timestamp")"
        timestamp="$(grep -v -- "0000:00:00" <<< "$timestamp")"

        if [ -n "$timestamp" ]
        then
            break
        fi
    done

    echo "$timestamp"                           # function "return"
}

rename_file()
{
    #echo ""${1}"  -->  "${2}.${extension}""
    destination="${2}.${extension}"
    
    if [ -e "$destination" ]
    then 
        msg_warning "target already exists, skipping .."
        return
    else
        echo "Would have executed: mv -nv -- "$1" "$destination""
    fi
}

main()
{
    input="$1"
    extension="${input##*.}"
    msg_debug "input image:     ${input}"
    msg_debug "input extension: ${extension}"

    timestamp="$(find_timestamp "$input")"

    if [ -z "$timestamp" ]
    then
        msg_warning "timestamp not found! search FAILED"
        return
    fi

    timestamp="$(clean_up_timestamp "$timestamp")"

    if [ -z "$timestamp" ]
    then
        # msg_warning "timestamp is NULL -- cleanup FAILED!"
        return
    fi
    msg_debug "timestamp: "$timestamp""


    rename_file "$input" "$timestamp"
    return
}


# ______________________________________________________________________________
# CODE EXECUTION STARTS HERE

if ! command -v "exiftool" >/dev/null
then
    die "failed to execute exiftool!"
fi

if [ "$#" -eq "0" ]
then
    die "Positional arguments missing! At least one is required."
else
    for arg in "$@"
    do
        main "$arg"
    done
fi

exit $?

